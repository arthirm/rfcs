- Start Date: 2018-04-27
- RFC PR:

# Summary

The goal of this RFC is to reduce the build time by avoiding to build the addons each time the application is built

# Motivation

For improving developer productivity reducing build time is crucial. During initial build of an ember application the addons that are not being developed as part of application are also built. This includes the addons from both node_modules and in-repo. Transpiling addons contribute to majority of the application build time. For large applications this is in the order of mins. Prebuilding addons will help reducing the application build time.

# Detailed design

Building an addon involves fetching the different trees (templates, app, vendor, addon, styles, public, test-support, addon-test-support, src) and transpiling them. 

The addons can be in-repo or external addons.
The external addons (present in node_modules) are never going to change unless we pull in the new version of the addon or we are directly modifying the addon in node_modules.
The in-repo addons may change if we are working on it or its dependent addons. In general it may have `isDeveloping` flag set if its being actively worked on.

Here we can see that inspite of not working on most of the addons we are building them every time.
Hence the idea is that during the initial cold build `ember build/serve` of an application or an addon, the result of each addon tree's transpiled output will be stored in a separate location so that it can be used for subsequent builds.

Key Considerations and Details,

-This is an Opt-In feature.
-A cache key is generated for prebuild and uses it to check if a prebuilt tree is valid. The cache key is built using the following parameters addon name, package, babel options, target browsers.
-Exclusion of addon(s) from prebuild is supported.
-The addons that are being developed will not be prebuilt/using prebuild. It can be identified from `isDeveloping` flag of an addon.
-Not all trees can be prebuilt. Only the addon trees that do not change between runs can be prebuilt. Hence the trees that are safe to prebuild are templates, addon, addon-test-support.
-Prebuild meta data information for each addon is persisted.
-Prebuild summaries are stored in a log file.
-Cleaning the prebuilt trees are supported by `ember prebuild:clearAll`

Each of the above point is discussed below in detail

## Opt-in Feature

This is an Opt in feature. The environment variable PREBUILD should be set to store or use the prebuilt trees.

## Good Defaults

The application is generally targeted to be run on a set of browsers (e.g, last 2 versions of evergreen browsers). The browser targets dictate the babel plugins that will be used to transpile the code. And the addons will also be transpiled using the targets specified by the app. Hence it is necessary to prebuild the addons for a set of target group and the app can choose to use the prebuilt addon for the target group it needs.

For each addon prebuild, a cache key is generated and the prebuild directory name represents the cache key.
The cache key for the addon involves addon name, package, babel options, target browsers etc. The prebuild tree will be used if the cache key matches.

```js
  cacheKeyParts = [
    addon.pkg && Object.keys(addon.pkg).sort(),
    addon.name,
    typeof addon.options.babel === 'function' ? addon.options.babel() : addon.options.babel,
    addon.options['ember-cli-babel'],
    targetBrowsers,
  ];
  return crypto.createHash('md5').update(stringify(cacheKeyParts), 'utf8').digest('hex');
```

The cache key will be different for `last 2 Chrome versions` and `last 1 Chrome version`. Even though the latter is a subset of the former the current design does not support using the same prebuild. Whether this needs to be supported or not is a topic of disucssion.

## Addon(s) Exclusion

Any addon(s) can be excluded from using this feature. It can be defined either in the package.json of the  application or as an environment variable. The addons to be excluded can be defined as an array or a string or a pattern of addon names.

Having this ability provides flexibility in the following scenarios.

-Changing the addon directly in node_modules
  During rebuild: Rebuild will not be triggered since the prebuild trees would be returned during the initial build hence the watchman will not be watching the actual addons but the prebuild addon.
  During Build: The change will not be reflected if the prebuild addon is already available, since the cache key does not check the code change and it will continue to return the prebuilt addon.

  Both of the scenarios can be handled but the build time gain will be lost handling these. Hence `EXCLUDEADDONS` can be used in this case.

-Features are removed from browsers, Errors in Babel or any dependent library
  Features removed from browsers are a rare scenario. But in the future we can consider `excluding` or `blacklisting` browsers as well if `exluding` addons are not enough.
  If an error is introduced in a library and it is fixed in the new version, the prebuild should be cleared and regenerated again. If the prebuild resides in npm then it needs to be published again.

## Trees for prebuild

By default, the templates, addon, addon-test-support, vendor trees will be prebuilt. A tree can be safely prebuilt if the `treeFor` hooks for the said trees are not being extended by the addon. If the hook has been extended, it is the responsibility of the addon owner to decide if the tree is safe to prebuilt else opt out of prebuilding the addon. As a next step, we can opt out of prebuilding a particular tree of an addon.

## Onus of prebuilding

Typically, the responsibility of storing the addon build should be shared by both the addon and the app.

-The addon should publish its prebuild everytime there is a change to the addon.
-The app can also prebuild and store locally or publish internally to company repoository.

Though the advantage of storing the addon build from an app is better because 
  Most of the addons do not specify target browsers
  The chances of addon and app's target and babel options to be different are reasonably common.

## Persistence

The addon can specify the location of prebuilt directory in its package.json. By default, the prebuilt directory will be stored inside the addon whether the addon is prebuilt by the app or the addon itself.

The prebuilt directory will contain one prebuilt addon tree for each target. Md5 checksum of each target file is used to generate the directory name. It will be in the format `pre-built/<addon-name?/<md5ChecksumOfTargetgroup>/<tree-type>`.

The location to store the prebuild addons can differ from team to team. Publishing the prebuilt addons either to npm or to a company repository will help in reducing the cold build.

## Metadata

Each prebuilt addon for a particular target will have a metadata file containing addon name, babel options and target browser versions. This indicates the target configurations for which the addon has been prebuilt.

## Summary

At the end of the build a prebuild log file (json) will be generated.
It will contain the addon name, prebuildPath, treeType, using prebuild (indicates whether prebuild is created or being used) for each of the addon tree created or used prebuild.

## Clear Prebuild

The prebuilt addons can be cleared using the command `ember prebuild:clearAll`. 
It can take addon glob pattern as parameter to indicate the addons for which prebuild can be cleared. By default clears prebuild for all addons in the project.

## Changes to Addon BluePrint

-`ember prebuild:clearAll` command should be added.
-Prebuilt directories should be ignored from being checkedin.

# How We Teach This

This feature can be documented in ember-cli guides to teach.

# Thanks
